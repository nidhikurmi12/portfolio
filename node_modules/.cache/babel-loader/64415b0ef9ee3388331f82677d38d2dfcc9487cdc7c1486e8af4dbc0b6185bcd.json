{"ast":null,"code":"import _slicedToArray from \"C:/Users/HP/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"C:/Users/HP/Desktop/portfolio/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\nimport { resolveOption } from '../utils/stagger.es.js';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { withControls } from '../animate/utils/controls.es.js';\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { isTransform } from '../animate/utils/transforms.es.js';\nimport { calcNextTime } from './utils/calc-time.es.js';\nimport { addKeyframes } from './utils/edit.es.js';\nimport { compareByTime } from './utils/sort.es.js';\nfunction timeline(definition) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a;\n  var animationDefinitions = createAnimationsFromTimeline(definition, options);\n  /**\n   * Create and start animations\n   */\n  var animationFactories = animationDefinitions.map(function (definition) {\n    return animateStyle.apply(void 0, _toConsumableArray(definition));\n  }).filter(Boolean);\n  return withControls(animationFactories, options,\n  // Get the duration from the first animation definition\n  (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition) {\n  var _a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _a$defaultOptions = _a.defaultOptions,\n    defaultOptions = _a$defaultOptions === void 0 ? {} : _a$defaultOptions,\n    timelineOptions = __rest(_a, [\"defaultOptions\"]);\n  var animationDefinitions = [];\n  var elementSequences = new Map();\n  var elementCache = {};\n  var timeLabels = new Map();\n  var prevTime = 0;\n  var currentTime = 0;\n  var totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the definition array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n  for (var i = 0; i < definition.length; i++) {\n    var segment = definition[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n    if (isString(segment)) {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n    var _segment = _slicedToArray(segment, 3),\n      elementDefinition = _segment[0],\n      keyframes = _segment[1],\n      _segment$ = _segment[2],\n      options = _segment$ === void 0 ? {} : _segment$;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n    if (options.at !== undefined) {\n      currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n    var maxDuration = 0;\n    /**\n     * Find all the elements specified in the definition and parse value\n     * keyframes from their timeline definitions.\n     */\n    var elements = resolveElements(elementDefinition, elementCache);\n    var numElements = elements.length;\n    for (var elementIndex = 0; elementIndex < numElements; elementIndex++) {\n      var element = elements[elementIndex];\n      var elementSequence = getElementSequence(element, elementSequences);\n      for (var key in keyframes) {\n        var valueSequence = getValueSequence(key, elementSequence);\n        var valueKeyframes = keyframesList(keyframes[key]);\n        var valueOptions = getOptions(options, key);\n        var _valueOptions$duratio = valueOptions.duration,\n          duration = _valueOptions$duratio === void 0 ? defaultOptions.duration || defaults.duration : _valueOptions$duratio,\n          _valueOptions$easing = valueOptions.easing,\n          easing = _valueOptions$easing === void 0 ? defaultOptions.easing || defaults.easing : _valueOptions$easing;\n        if (isEasingGenerator(easing)) {\n          var valueIsTransform = isTransform(key);\n          invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n          var custom = easing.createAnimation(valueKeyframes,\n          // TODO We currently only support explicit keyframes\n          // so this doesn't currently read from the DOM\n          function () {\n            return \"0\";\n          }, valueIsTransform);\n          easing = custom.easing;\n          if (custom.keyframes !== undefined) valueKeyframes = custom.keyframes;\n          if (custom.duration !== undefined) duration = custom.duration;\n        }\n        var delay = resolveOption(options.delay, elementIndex, numElements) || 0;\n        var startTime = currentTime + delay;\n        var targetTime = startTime + duration;\n        /**\n         *\n         */\n        var _valueOptions$offset = valueOptions.offset,\n          offset = _valueOptions$offset === void 0 ? defaultOffset(valueKeyframes.length) : _valueOptions$offset;\n        /**\n         * If there's only one offset of 0, fill in a second with length 1\n         *\n         * TODO: Ensure there's a test that covers this removal\n         */\n        if (offset.length === 1 && offset[0] === 0) {\n          offset[1] = 1;\n        }\n        /**\n         * Fill out if offset if fewer offsets than keyframes\n         */\n        var remainder = length - valueKeyframes.length;\n        remainder > 0 && fillOffset(offset, remainder);\n        /**\n         * If only one value has been set, ie [1], push a null to the start of\n         * the keyframe array. This will let us mark a keyframe at this point\n         * that will later be hydrated with the previous value.\n         */\n        valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n        /**\n         * Add keyframes, mapping offsets to absolute time.\n         */\n        addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n        maxDuration = Math.max(delay + duration, maxDuration);\n        totalDuration = Math.max(targetTime, totalDuration);\n      }\n    }\n    prevTime = currentTime;\n    currentTime += maxDuration;\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n  elementSequences.forEach(function (valueSequences, element) {\n    for (var _key in valueSequences) {\n      var _valueSequence = valueSequences[_key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n      _valueSequence.sort(compareByTime);\n      var _keyframes = [];\n      var valueOffset = [];\n      var valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n      for (var _i = 0; _i < _valueSequence.length; _i++) {\n        var _valueSequence$_i = _valueSequence[_i],\n          at = _valueSequence$_i.at,\n          value = _valueSequence$_i.value,\n          _easing = _valueSequence$_i.easing;\n        _keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(_easing || defaults.easing);\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        _keyframes.unshift(_keyframes[0]);\n        valueEasing.unshift(\"linear\");\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        _keyframes.push(null);\n      }\n      animationDefinitions.push([element, _key, _keyframes, Object.assign(Object.assign(Object.assign({}, defaultOptions), {\n        duration: totalDuration,\n        easing: valueEasing,\n        offset: valueOffset\n      }), timelineOptions)]);\n    }\n  });\n  return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n  !sequences.has(element) && sequences.set(element, {});\n  return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nexport { createAnimationsFromTimeline, timeline };","map":{"version":3,"names":["__rest","invariant","isString","defaults","isEasingGenerator","defaultOffset","fillOffset","progress","resolveOption","animateStyle","withControls","keyframesList","getOptions","resolveElements","isTransform","calcNextTime","addKeyframes","compareByTime","timeline","definition","options","arguments","length","undefined","_a","animationDefinitions","createAnimationsFromTimeline","animationFactories","map","apply","_toConsumableArray","filter","Boolean","duration","_a$defaultOptions","defaultOptions","timelineOptions","elementSequences","Map","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","segment","set","Array","isArray","name","at","_segment","_slicedToArray","elementDefinition","keyframes","_segment$","maxDuration","elements","numElements","elementIndex","element","elementSequence","getElementSequence","key","valueSequence","getValueSequence","valueKeyframes","valueOptions","_valueOptions$duratio","_valueOptions$easing","easing","valueIsTransform","custom","createAnimation","delay","startTime","targetTime","_valueOptions$offset","offset","remainder","unshift","Math","max","forEach","valueSequences","sort","valueOffset","valueEasing","_valueSequence$_i","value","push","Object","assign","sequences","has","get"],"sources":["C:/Users/HP/Desktop/portfolio/node_modules/@motionone/dom/dist/timeline/index.es.js"],"sourcesContent":["import { __rest } from 'tslib';\nimport { invariant } from 'hey-listen';\nimport { isString, defaults, isEasingGenerator, defaultOffset, fillOffset, progress } from '@motionone/utils';\nimport { resolveOption } from '../utils/stagger.es.js';\nimport { animateStyle } from '../animate/animate-style.es.js';\nimport { withControls } from '../animate/utils/controls.es.js';\nimport { keyframesList } from '../animate/utils/keyframes.es.js';\nimport { getOptions } from '../animate/utils/options.es.js';\nimport { resolveElements } from '../utils/resolve-elements.es.js';\nimport { isTransform } from '../animate/utils/transforms.es.js';\nimport { calcNextTime } from './utils/calc-time.es.js';\nimport { addKeyframes } from './utils/edit.es.js';\nimport { compareByTime } from './utils/sort.es.js';\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle(...definition))\n        .filter(Boolean);\n    return withControls(animationFactories, options, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = __rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const segment = definition[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (isString(segment)) {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        const [elementDefinition, keyframes, options = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options.at !== undefined) {\n            currentTime = calcNextTime(currentTime, options.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframesList(keyframes[key]);\n                const valueOptions = getOptions(options, key);\n                let { duration = defaultOptions.duration || defaults.duration, easing = defaultOptions.easing || defaults.easing, } = valueOptions;\n                if (isEasingGenerator(easing)) {\n                    const valueIsTransform = isTransform(key);\n                    invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n                    const custom = easing.createAnimation(valueKeyframes, \n                    // TODO We currently only support explicit keyframes\n                    // so this doesn't currently read from the DOM\n                    () => \"0\", valueIsTransform);\n                    easing = custom.easing;\n                    if (custom.keyframes !== undefined)\n                        valueKeyframes = custom.keyframes;\n                    if (custom.duration !== undefined)\n                        duration = custom.duration;\n                }\n                const delay = resolveOption(options.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = length - valueKeyframes.length;\n                remainder > 0 && fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexport { createAnimationsFromTimeline, timeline };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}