{"ast":null,"code":"import { warnOnce } from '../../utils/warn-once.mjs';\nimport { motionValue } from '../../value/index.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nfunction updateMotionValuesFromProps(element, next, prev) {\n  var _a;\n  for (var key in next) {\n    var nextValue = next[key];\n    var prevValue = prev[key];\n    if (isMotionValue(nextValue)) {\n      /**\r\n       * If this is a motion value found in props or style, we want to add it\r\n       * to our visual element's motion value map.\r\n       */\n      element.addValue(key, nextValue);\n      /**\r\n       * Check the version of the incoming motion value with this version\r\n       * and warn against mismatches.\r\n       */\n      if (process.env.NODE_ENV === \"development\") {\n        warnOnce(nextValue.version === \"6.5.1\", \"Attempting to mix Framer Motion versions \".concat(nextValue.version, \" with 6.5.1 may not work as expected.\"));\n      }\n    } else if (isMotionValue(prevValue)) {\n      /**\r\n       * If we're swapping to a new motion value, create a new motion value\r\n       * from that\r\n       */\n      element.addValue(key, motionValue(nextValue));\n    } else if (prevValue !== nextValue) {\n      /**\r\n       * If this is a flat value that has changed, update the motion value\r\n       * or create one if it doesn't exist. We only want to do this if we're\r\n       * not handling the value with our animation state.\r\n       */\n      if (element.hasValue(key)) {\n        var existingValue = element.getValue(key);\n        // TODO: Only update values that aren't being animated or even looked at\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n      }\n    }\n  }\n  // Handle removed values\n  for (var key in prev) {\n    if (next[key] === undefined) element.removeValue(key);\n  }\n  return next;\n}\nexport { updateMotionValuesFromProps };","map":{"version":3,"names":["warnOnce","motionValue","isMotionValue","updateMotionValuesFromProps","element","next","prev","_a","key","nextValue","prevValue","addValue","process","env","NODE_ENV","version","concat","hasValue","existingValue","getValue","hasAnimated","set","getStaticValue","undefined","removeValue"],"sources":["C:/Users/vikas/OneDrive/Desktop/k folder/nk-portfolio/node_modules/framer-motion/dist/es/render/utils/motion-values.mjs"],"sourcesContent":["import { warnOnce } from '../../utils/warn-once.mjs';\r\nimport { motionValue } from '../../value/index.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nfunction updateMotionValuesFromProps(element, next, prev) {\r\n    var _a;\r\n    for (var key in next) {\r\n        var nextValue = next[key];\r\n        var prevValue = prev[key];\r\n        if (isMotionValue(nextValue)) {\r\n            /**\r\n             * If this is a motion value found in props or style, we want to add it\r\n             * to our visual element's motion value map.\r\n             */\r\n            element.addValue(key, nextValue);\r\n            /**\r\n             * Check the version of the incoming motion value with this version\r\n             * and warn against mismatches.\r\n             */\r\n            if (process.env.NODE_ENV === \"development\") {\r\n                warnOnce(nextValue.version === \"6.5.1\", \"Attempting to mix Framer Motion versions \".concat(nextValue.version, \" with 6.5.1 may not work as expected.\"));\r\n            }\r\n        }\r\n        else if (isMotionValue(prevValue)) {\r\n            /**\r\n             * If we're swapping to a new motion value, create a new motion value\r\n             * from that\r\n             */\r\n            element.addValue(key, motionValue(nextValue));\r\n        }\r\n        else if (prevValue !== nextValue) {\r\n            /**\r\n             * If this is a flat value that has changed, update the motion value\r\n             * or create one if it doesn't exist. We only want to do this if we're\r\n             * not handling the value with our animation state.\r\n             */\r\n            if (element.hasValue(key)) {\r\n                var existingValue = element.getValue(key);\r\n                // TODO: Only update values that aren't being animated or even looked at\r\n                !existingValue.hasAnimated && existingValue.set(nextValue);\r\n            }\r\n            else {\r\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\r\n            }\r\n        }\r\n    }\r\n    // Handle removed values\r\n    for (var key in prev) {\r\n        if (next[key] === undefined)\r\n            element.removeValue(key);\r\n    }\r\n    return next;\r\n}\r\n\r\nexport { updateMotionValuesFromProps };\r\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,2BAA2B;AACpD,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,aAAa,QAAQ,uCAAuC;AAErE,SAASC,2BAA2BA,CAACC,OAAO,EAAEC,IAAI,EAAEC,IAAI,EAAE;EACtD,IAAIC,EAAE;EACN,KAAK,IAAIC,GAAG,IAAIH,IAAI,EAAE;IAClB,IAAII,SAAS,GAAGJ,IAAI,CAACG,GAAG,CAAC;IACzB,IAAIE,SAAS,GAAGJ,IAAI,CAACE,GAAG,CAAC;IACzB,IAAIN,aAAa,CAACO,SAAS,CAAC,EAAE;MAC1B;AACZ;AACA;AACA;MACYL,OAAO,CAACO,QAAQ,CAACH,GAAG,EAAEC,SAAS,CAAC;MAChC;AACZ;AACA;AACA;MACY,IAAIG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,aAAa,EAAE;QACxCd,QAAQ,CAACS,SAAS,CAACM,OAAO,KAAK,OAAO,EAAE,2CAA2C,CAACC,MAAM,CAACP,SAAS,CAACM,OAAO,EAAE,uCAAuC,CAAC,CAAC;MAC3J;IACJ,CAAC,MACI,IAAIb,aAAa,CAACQ,SAAS,CAAC,EAAE;MAC/B;AACZ;AACA;AACA;MACYN,OAAO,CAACO,QAAQ,CAACH,GAAG,EAAEP,WAAW,CAACQ,SAAS,CAAC,CAAC;IACjD,CAAC,MACI,IAAIC,SAAS,KAAKD,SAAS,EAAE;MAC9B;AACZ;AACA;AACA;AACA;MACY,IAAIL,OAAO,CAACa,QAAQ,CAACT,GAAG,CAAC,EAAE;QACvB,IAAIU,aAAa,GAAGd,OAAO,CAACe,QAAQ,CAACX,GAAG,CAAC;QACzC;QACA,CAACU,aAAa,CAACE,WAAW,IAAIF,aAAa,CAACG,GAAG,CAACZ,SAAS,CAAC;MAC9D,CAAC,MACI;QACDL,OAAO,CAACO,QAAQ,CAACH,GAAG,EAAEP,WAAW,CAAC,CAACM,EAAE,GAAGH,OAAO,CAACkB,cAAc,CAACd,GAAG,CAAC,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGE,SAAS,CAAC,CAAC;MACrH;IACJ;EACJ;EACA;EACA,KAAK,IAAID,GAAG,IAAIF,IAAI,EAAE;IAClB,IAAID,IAAI,CAACG,GAAG,CAAC,KAAKe,SAAS,EACvBnB,OAAO,CAACoB,WAAW,CAAChB,GAAG,CAAC;EAChC;EACA,OAAOH,IAAI;AACf;AAEA,SAASF,2BAA2B"},"metadata":{},"sourceType":"module","externalDependencies":[]}