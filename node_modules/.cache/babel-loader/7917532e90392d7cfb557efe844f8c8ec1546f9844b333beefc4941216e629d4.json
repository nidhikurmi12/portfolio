{"ast":null,"code":"import { now } from '../../shared/utils.js';\nexport default function freeMode(_ref) {\n  let {\n    swiper,\n    extendParams,\n    emit,\n    once\n  } = _ref;\n  extendParams({\n    freeMode: {\n      enabled: false,\n      momentum: true,\n      momentumRatio: 1,\n      momentumBounce: true,\n      momentumBounceRatio: 1,\n      momentumVelocityRatio: 1,\n      sticky: false,\n      minimumVelocity: 0.02\n    }\n  });\n  function onTouchStart() {\n    const translate = swiper.getTranslate();\n    swiper.setTranslate(translate);\n    swiper.setTransition(0);\n    swiper.touchEventsData.velocities.length = 0;\n    swiper.freeMode.onTouchEnd({\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\n    });\n  }\n  function onTouchMove() {\n    const {\n      touchEventsData: data,\n      touches\n    } = swiper; // Velocity\n\n    if (data.velocities.length === 0) {\n      data.velocities.push({\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\n        time: data.touchStartTime\n      });\n    }\n    data.velocities.push({\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\n      time: now()\n    });\n  }\n  function onTouchEnd(_ref2) {\n    let {\n      currentPos\n    } = _ref2;\n    const {\n      params,\n      $wrapperEl,\n      rtlTranslate: rtl,\n      snapGrid,\n      touchEventsData: data\n    } = swiper; // Time diff\n\n    const touchEndTime = now();\n    const timeDiff = touchEndTime - data.touchStartTime;\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n    if (params.freeMode.momentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeMode.momentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeMode.sticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeMode.sticky) {\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeMode.sticky) {\n        swiper.slideToClosest();\n        return;\n      }\n      if (params.freeMode.momentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          setTimeout(() => {\n            swiper.setTranslate(afterBouncePosition);\n            $wrapperEl.transitionEnd(() => {\n              if (!swiper || swiper.destroyed) return;\n              swiper.transitionEnd();\n            });\n          }, 0);\n        });\n      } else if (swiper.velocity) {\n        emit('_freeModeNoMomentumRelease');\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeMode.sticky) {\n      swiper.slideToClosest();\n      return;\n    } else if (params.freeMode) {\n      emit('_freeModeNoMomentumRelease');\n    }\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n  }\n  Object.assign(swiper, {\n    freeMode: {\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd\n    }\n  });\n}","map":{"version":3,"names":["now","freeMode","_ref","swiper","extendParams","emit","once","enabled","momentum","momentumRatio","momentumBounce","momentumBounceRatio","momentumVelocityRatio","sticky","minimumVelocity","onTouchStart","translate","getTranslate","setTranslate","setTransition","touchEventsData","velocities","length","onTouchEnd","currentPos","rtl","onTouchMove","data","touches","push","position","isHorizontal","time","touchStartTime","_ref2","params","$wrapperEl","rtlTranslate","snapGrid","touchEndTime","timeDiff","minTranslate","slideTo","activeIndex","maxTranslate","slides","lastMoveEvent","pop","velocityEvent","distance","velocity","Math","abs","momentumDuration","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","needsLoopFix","allowMomentumBounce","loop","centeredSlides","nextSlide","j","swipeDirection","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","transitionStart","animating","transitionEnd","destroyed","setTimeout","updateActiveIndex","updateSlidesClasses","longSwipesMs","Object","assign"],"sources":["C:/Users/vikas/OneDrive/Desktop/nk folder/nk-portfolio/node_modules/swiper/modules/free-mode/free-mode.js"],"sourcesContent":["import { now } from '../../shared/utils.js';\r\nexport default function freeMode({\r\n  swiper,\r\n  extendParams,\r\n  emit,\r\n  once\r\n}) {\r\n  extendParams({\r\n    freeMode: {\r\n      enabled: false,\r\n      momentum: true,\r\n      momentumRatio: 1,\r\n      momentumBounce: true,\r\n      momentumBounceRatio: 1,\r\n      momentumVelocityRatio: 1,\r\n      sticky: false,\r\n      minimumVelocity: 0.02\r\n    }\r\n  });\r\n\r\n  function onTouchStart() {\r\n    const translate = swiper.getTranslate();\r\n    swiper.setTranslate(translate);\r\n    swiper.setTransition(0);\r\n    swiper.touchEventsData.velocities.length = 0;\r\n    swiper.freeMode.onTouchEnd({\r\n      currentPos: swiper.rtl ? swiper.translate : -swiper.translate\r\n    });\r\n  }\r\n\r\n  function onTouchMove() {\r\n    const {\r\n      touchEventsData: data,\r\n      touches\r\n    } = swiper; // Velocity\r\n\r\n    if (data.velocities.length === 0) {\r\n      data.velocities.push({\r\n        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],\r\n        time: data.touchStartTime\r\n      });\r\n    }\r\n\r\n    data.velocities.push({\r\n      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],\r\n      time: now()\r\n    });\r\n  }\r\n\r\n  function onTouchEnd({\r\n    currentPos\r\n  }) {\r\n    const {\r\n      params,\r\n      $wrapperEl,\r\n      rtlTranslate: rtl,\r\n      snapGrid,\r\n      touchEventsData: data\r\n    } = swiper; // Time diff\r\n\r\n    const touchEndTime = now();\r\n    const timeDiff = touchEndTime - data.touchStartTime;\r\n\r\n    if (currentPos < -swiper.minTranslate()) {\r\n      swiper.slideTo(swiper.activeIndex);\r\n      return;\r\n    }\r\n\r\n    if (currentPos > -swiper.maxTranslate()) {\r\n      if (swiper.slides.length < snapGrid.length) {\r\n        swiper.slideTo(snapGrid.length - 1);\r\n      } else {\r\n        swiper.slideTo(swiper.slides.length - 1);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (params.freeMode.momentum) {\r\n      if (data.velocities.length > 1) {\r\n        const lastMoveEvent = data.velocities.pop();\r\n        const velocityEvent = data.velocities.pop();\r\n        const distance = lastMoveEvent.position - velocityEvent.position;\r\n        const time = lastMoveEvent.time - velocityEvent.time;\r\n        swiper.velocity = distance / time;\r\n        swiper.velocity /= 2;\r\n\r\n        if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {\r\n          swiper.velocity = 0;\r\n        } // this implies that the user stopped moving a finger then released.\r\n        // There would be no events with distance zero, so the last event is stale.\r\n\r\n\r\n        if (time > 150 || now() - lastMoveEvent.time > 300) {\r\n          swiper.velocity = 0;\r\n        }\r\n      } else {\r\n        swiper.velocity = 0;\r\n      }\r\n\r\n      swiper.velocity *= params.freeMode.momentumVelocityRatio;\r\n      data.velocities.length = 0;\r\n      let momentumDuration = 1000 * params.freeMode.momentumRatio;\r\n      const momentumDistance = swiper.velocity * momentumDuration;\r\n      let newPosition = swiper.translate + momentumDistance;\r\n      if (rtl) newPosition = -newPosition;\r\n      let doBounce = false;\r\n      let afterBouncePosition;\r\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;\r\n      let needsLoopFix;\r\n\r\n      if (newPosition < swiper.maxTranslate()) {\r\n        if (params.freeMode.momentumBounce) {\r\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\r\n            newPosition = swiper.maxTranslate() - bounceAmount;\r\n          }\r\n\r\n          afterBouncePosition = swiper.maxTranslate();\r\n          doBounce = true;\r\n          data.allowMomentumBounce = true;\r\n        } else {\r\n          newPosition = swiper.maxTranslate();\r\n        }\r\n\r\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\r\n      } else if (newPosition > swiper.minTranslate()) {\r\n        if (params.freeMode.momentumBounce) {\r\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\r\n            newPosition = swiper.minTranslate() + bounceAmount;\r\n          }\r\n\r\n          afterBouncePosition = swiper.minTranslate();\r\n          doBounce = true;\r\n          data.allowMomentumBounce = true;\r\n        } else {\r\n          newPosition = swiper.minTranslate();\r\n        }\r\n\r\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\r\n      } else if (params.freeMode.sticky) {\r\n        let nextSlide;\r\n\r\n        for (let j = 0; j < snapGrid.length; j += 1) {\r\n          if (snapGrid[j] > -newPosition) {\r\n            nextSlide = j;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\r\n          newPosition = snapGrid[nextSlide];\r\n        } else {\r\n          newPosition = snapGrid[nextSlide - 1];\r\n        }\r\n\r\n        newPosition = -newPosition;\r\n      }\r\n\r\n      if (needsLoopFix) {\r\n        once('transitionEnd', () => {\r\n          swiper.loopFix();\r\n        });\r\n      } // Fix duration\r\n\r\n\r\n      if (swiper.velocity !== 0) {\r\n        if (rtl) {\r\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\r\n        } else {\r\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\r\n        }\r\n\r\n        if (params.freeMode.sticky) {\r\n          // If freeMode.sticky is active and the user ends a swipe with a slow-velocity\r\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\r\n          // It's easy to see this when simulating touch with mouse events. To fix this,\r\n          // limit single-slide swipes to the default slide duration. This also has the\r\n          // nice side effect of matching slide speed if the user stopped moving before\r\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\r\n          // For faster swipes, also apply limits (albeit higher ones).\r\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\r\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\r\n\r\n          if (moveDistance < currentSlideSize) {\r\n            momentumDuration = params.speed;\r\n          } else if (moveDistance < 2 * currentSlideSize) {\r\n            momentumDuration = params.speed * 1.5;\r\n          } else {\r\n            momentumDuration = params.speed * 2.5;\r\n          }\r\n        }\r\n      } else if (params.freeMode.sticky) {\r\n        swiper.slideToClosest();\r\n        return;\r\n      }\r\n\r\n      if (params.freeMode.momentumBounce && doBounce) {\r\n        swiper.updateProgress(afterBouncePosition);\r\n        swiper.setTransition(momentumDuration);\r\n        swiper.setTranslate(newPosition);\r\n        swiper.transitionStart(true, swiper.swipeDirection);\r\n        swiper.animating = true;\r\n        $wrapperEl.transitionEnd(() => {\r\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\r\n          emit('momentumBounce');\r\n          swiper.setTransition(params.speed);\r\n          setTimeout(() => {\r\n            swiper.setTranslate(afterBouncePosition);\r\n            $wrapperEl.transitionEnd(() => {\r\n              if (!swiper || swiper.destroyed) return;\r\n              swiper.transitionEnd();\r\n            });\r\n          }, 0);\r\n        });\r\n      } else if (swiper.velocity) {\r\n        emit('_freeModeNoMomentumRelease');\r\n        swiper.updateProgress(newPosition);\r\n        swiper.setTransition(momentumDuration);\r\n        swiper.setTranslate(newPosition);\r\n        swiper.transitionStart(true, swiper.swipeDirection);\r\n\r\n        if (!swiper.animating) {\r\n          swiper.animating = true;\r\n          $wrapperEl.transitionEnd(() => {\r\n            if (!swiper || swiper.destroyed) return;\r\n            swiper.transitionEnd();\r\n          });\r\n        }\r\n      } else {\r\n        swiper.updateProgress(newPosition);\r\n      }\r\n\r\n      swiper.updateActiveIndex();\r\n      swiper.updateSlidesClasses();\r\n    } else if (params.freeMode.sticky) {\r\n      swiper.slideToClosest();\r\n      return;\r\n    } else if (params.freeMode) {\r\n      emit('_freeModeNoMomentumRelease');\r\n    }\r\n\r\n    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {\r\n      swiper.updateProgress();\r\n      swiper.updateActiveIndex();\r\n      swiper.updateSlidesClasses();\r\n    }\r\n  }\r\n\r\n  Object.assign(swiper, {\r\n    freeMode: {\r\n      onTouchStart,\r\n      onTouchMove,\r\n      onTouchEnd\r\n    }\r\n  });\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}