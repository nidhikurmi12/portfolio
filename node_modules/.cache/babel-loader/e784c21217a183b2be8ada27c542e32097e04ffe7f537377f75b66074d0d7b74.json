{"ast":null,"code":"import { __assign } from 'tslib';\nimport * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { useFeatures } from './features/use-features.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { loadFeatures, featureDefinitions } from './features/definitions.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { useProjectionId } from '../projection/node/id.mjs';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { useProjection } from './features/use-projection.mjs';\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\n\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n */\nfunction createMotionComponent(_a) {\n  var preloadedFeatures = _a.preloadedFeatures,\n    createVisualElement = _a.createVisualElement,\n    projectionNodeConstructor = _a.projectionNodeConstructor,\n    useRender = _a.useRender,\n    useVisualState = _a.useVisualState,\n    Component = _a.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n  function MotionComponent(props, externalRef) {\n    var layoutId = useLayoutId(props);\n    props = __assign(__assign({}, props), {\n      layoutId: layoutId\n    });\n    /**\r\n     * If we're rendering in a static environment, we only visually update the component\r\n     * as a result of a React-rerender rather than interactions or animations. This\r\n     * means we don't need to load additional memory structures like VisualElement,\r\n     * or any gesture/animation features.\r\n     */\n    var config = useContext(MotionConfigContext);\n    var features = null;\n    var context = useCreateMotionContext(props);\n    /**\r\n     * Create a unique projection ID for this component. If a new component is added\r\n     * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\r\n     * us to measure it as soon as any layout effect flushes pending layout animations.\r\n     *\r\n     * Performance note: It'd be better not to have to search the DOM for these elements.\r\n     * For newly-entering components it could be enough to only correct treeScale, in which\r\n     * case we could mount in a scale-correction mode. This wouldn't be enough for\r\n     * shared element transitions however. Perhaps for those we could revert to a root node\r\n     * that gets forceRendered and layout animations are triggered on its layout effect.\r\n     */\n    var projectionId = config.isStatic ? undefined : useProjectionId();\n    /**\r\n     *\r\n     */\n    var visualState = useVisualState(props, config.isStatic);\n    if (!config.isStatic && isBrowser) {\n      /**\r\n       * Create a VisualElement for this component. A VisualElement provides a common\r\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n       * providing a way of rendering to these APIs outside of the React render loop\r\n       * for more performant animations and interactions\r\n       */\n      context.visualElement = useVisualElement(Component, visualState, __assign(__assign({}, config), props), createVisualElement);\n      useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);\n      /**\r\n       * Load Motion gesture and animation features. These are rendered as renderless\r\n       * components so each feature can optionally make use of React lifecycle methods.\r\n       */\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    /**\r\n     * The mount order and hierarchy is specific to ensure our element ref\r\n     * is hydrated by the time features fire their effects.\r\n     */\n    return React.createElement(VisualElementHandler, {\n      visualElement: context.visualElement,\n      props: __assign(__assign({}, config), props)\n    }, features, React.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement)));\n  }\n  return forwardRef(MotionComponent);\n}\nfunction useLayoutId(_a) {\n  var _b;\n  var layoutId = _a.layoutId;\n  var layoutGroupId = (_b = useContext(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\nexport { createMotionComponent };","map":{"version":3,"names":["__assign","React","forwardRef","useContext","useFeatures","MotionConfigContext","MotionContext","useVisualElement","useMotionRef","useCreateMotionContext","loadFeatures","featureDefinitions","isBrowser","useProjectionId","LayoutGroupContext","useProjection","VisualElementHandler","createMotionComponent","_a","preloadedFeatures","createVisualElement","projectionNodeConstructor","useRender","useVisualState","Component","MotionComponent","props","externalRef","layoutId","useLayoutId","config","features","context","projectionId","isStatic","undefined","visualState","visualElement","createElement","Provider","value","_b","layoutGroupId","id"],"sources":["C:/Users/vikas/OneDrive/Desktop/nk folder/nk-portfolio/node_modules/framer-motion/dist/es/motion/index.mjs"],"sourcesContent":["import { __assign } from 'tslib';\r\nimport * as React from 'react';\r\nimport { forwardRef, useContext } from 'react';\r\nimport { useFeatures } from './features/use-features.mjs';\r\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\r\nimport { MotionContext } from '../context/MotionContext/index.mjs';\r\nimport { useVisualElement } from './utils/use-visual-element.mjs';\r\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\r\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\r\nimport { loadFeatures, featureDefinitions } from './features/definitions.mjs';\r\nimport { isBrowser } from '../utils/is-browser.mjs';\r\nimport { useProjectionId } from '../projection/node/id.mjs';\r\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\r\nimport { useProjection } from './features/use-projection.mjs';\r\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\r\n\r\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n */\r\nfunction createMotionComponent(_a) {\r\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, projectionNodeConstructor = _a.projectionNodeConstructor, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\r\n    preloadedFeatures && loadFeatures(preloadedFeatures);\r\n    function MotionComponent(props, externalRef) {\r\n        var layoutId = useLayoutId(props);\r\n        props = __assign(__assign({}, props), { layoutId: layoutId });\r\n        /**\r\n         * If we're rendering in a static environment, we only visually update the component\r\n         * as a result of a React-rerender rather than interactions or animations. This\r\n         * means we don't need to load additional memory structures like VisualElement,\r\n         * or any gesture/animation features.\r\n         */\r\n        var config = useContext(MotionConfigContext);\r\n        var features = null;\r\n        var context = useCreateMotionContext(props);\r\n        /**\r\n         * Create a unique projection ID for this component. If a new component is added\r\n         * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\r\n         * us to measure it as soon as any layout effect flushes pending layout animations.\r\n         *\r\n         * Performance note: It'd be better not to have to search the DOM for these elements.\r\n         * For newly-entering components it could be enough to only correct treeScale, in which\r\n         * case we could mount in a scale-correction mode. This wouldn't be enough for\r\n         * shared element transitions however. Perhaps for those we could revert to a root node\r\n         * that gets forceRendered and layout animations are triggered on its layout effect.\r\n         */\r\n        var projectionId = config.isStatic ? undefined : useProjectionId();\r\n        /**\r\n         *\r\n         */\r\n        var visualState = useVisualState(props, config.isStatic);\r\n        if (!config.isStatic && isBrowser) {\r\n            /**\r\n             * Create a VisualElement for this component. A VisualElement provides a common\r\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n             * providing a way of rendering to these APIs outside of the React render loop\r\n             * for more performant animations and interactions\r\n             */\r\n            context.visualElement = useVisualElement(Component, visualState, __assign(__assign({}, config), props), createVisualElement);\r\n            useProjection(projectionId, props, context.visualElement, projectionNodeConstructor ||\r\n                featureDefinitions.projectionNodeConstructor);\r\n            /**\r\n             * Load Motion gesture and animation features. These are rendered as renderless\r\n             * components so each feature can optionally make use of React lifecycle methods.\r\n             */\r\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\r\n        }\r\n        /**\r\n         * The mount order and hierarchy is specific to ensure our element ref\r\n         * is hydrated by the time features fire their effects.\r\n         */\r\n        return (React.createElement(VisualElementHandler, { visualElement: context.visualElement, props: __assign(__assign({}, config), props) },\r\n            features,\r\n            React.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement))));\r\n    }\r\n    return forwardRef(MotionComponent);\r\n}\r\nfunction useLayoutId(_a) {\r\n    var _b;\r\n    var layoutId = _a.layoutId;\r\n    var layoutGroupId = (_b = useContext(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;\r\n    return layoutGroupId && layoutId !== undefined\r\n        ? layoutGroupId + \"-\" + layoutId\r\n        : layoutId;\r\n}\r\n\r\nexport { createMotionComponent };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}