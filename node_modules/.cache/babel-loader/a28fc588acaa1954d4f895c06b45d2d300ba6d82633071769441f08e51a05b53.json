{"ast":null,"code":"import { __assign, __read } from 'tslib';\nimport { number, px } from 'style-value-types';\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\nimport { invariant } from 'hey-listen';\nimport { transformProps } from '../../html/utils/transform.mjs';\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\nvar positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\"]);\nvar isPositionalKey = function (key) {\n  return positionalKeys.has(key);\n};\nvar hasPositionalKey = function (target) {\n  return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n  // Looks odd but setting it twice doesn't render, it'll just\n  // set both prev and current to the latest value\n  value.set(to, false);\n  value.set(to);\n};\nvar isNumOrPxType = function (v) {\n  return v === number || v === px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n  BoundingBoxDimension[\"width\"] = \"width\";\n  BoundingBoxDimension[\"height\"] = \"height\";\n  BoundingBoxDimension[\"left\"] = \"left\";\n  BoundingBoxDimension[\"right\"] = \"right\";\n  BoundingBoxDimension[\"top\"] = \"top\";\n  BoundingBoxDimension[\"bottom\"] = \"bottom\";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n  return parseFloat(matrix.split(\", \")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) {\n  return function (_bbox, _a) {\n    var transform = _a.transform;\n    if (transform === \"none\" || !transform) return 0;\n    var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n      return getPosFromMatrix(matrix3d[1], pos3);\n    } else {\n      var matrix = transform.match(/^matrix\\((.+)\\)$/);\n      if (matrix) {\n        return getPosFromMatrix(matrix[1], pos2);\n      } else {\n        return 0;\n      }\n    }\n  };\n};\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) {\n  return !transformKeys.has(key);\n});\nfunction removeNonTranslationalTransform(visualElement) {\n  var removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  // Apply changes to element before measurement\n  if (removedTransforms.length) visualElement.syncRender();\n  return removedTransforms;\n}\nvar positionalValues = {\n  // Dimensions\n  width: function (_a, _b) {\n    var x = _a.x;\n    var _c = _b.paddingLeft,\n      paddingLeft = _c === void 0 ? \"0\" : _c,\n      _d = _b.paddingRight,\n      paddingRight = _d === void 0 ? \"0\" : _d;\n    return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n  },\n  height: function (_a, _b) {\n    var y = _a.y;\n    var _c = _b.paddingTop,\n      paddingTop = _c === void 0 ? \"0\" : _c,\n      _d = _b.paddingBottom,\n      paddingBottom = _d === void 0 ? \"0\" : _d;\n    return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n  },\n  top: function (_bbox, _a) {\n    var top = _a.top;\n    return parseFloat(top);\n  },\n  left: function (_bbox, _a) {\n    var left = _a.left;\n    return parseFloat(left);\n  },\n  bottom: function (_a, _b) {\n    var y = _a.y;\n    var top = _b.top;\n    return parseFloat(top) + (y.max - y.min);\n  },\n  right: function (_a, _b) {\n    var x = _a.x;\n    var left = _b.left;\n    return parseFloat(left) + (x.max - x.min);\n  },\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n  var originBbox = visualElement.measureViewportBox();\n  var element = visualElement.getInstance();\n  var elementComputedStyle = getComputedStyle(element);\n  var display = elementComputedStyle.display;\n  var origin = {};\n  // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  /**\r\n   * Record origins before we render and update styles\r\n   */\n  changedKeys.forEach(function (key) {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  });\n  // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n  visualElement.syncRender();\n  var targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(function (key) {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    var value = visualElement.getValue(key);\n    setAndResetVelocity(value, origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n  if (origin === void 0) {\n    origin = {};\n  }\n  if (transitionEnd === void 0) {\n    transitionEnd = {};\n  }\n  target = __assign({}, target);\n  transitionEnd = __assign({}, transitionEnd);\n  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n  var removedTransformValues = [];\n  var hasAttemptedToRemoveTransformValues = false;\n  var changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(function (key) {\n    var value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    var from = origin[key];\n    var fromType = findDimensionValueType(from);\n    var to = target[key];\n    var toType;\n    // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n    if (isKeyframesTarget(to)) {\n      var numKeyframes = to.length;\n      var fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n      for (var i = fromIndex; i < numKeyframes; i++) {\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        var current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        setAndResetVelocity(value, to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    var scrollY_1 = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    // If we removed transform values, reapply them before the next render\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(function (_a) {\n        var _b = __read(_a, 2),\n          key = _b[0],\n          value = _b[1];\n        visualElement.getValue(key).set(value);\n      });\n    }\n    // Reapply original values\n    visualElement.syncRender();\n    // Restore scroll position\n    if (scrollY_1 !== null) window.scrollTo({\n      top: scrollY_1\n    });\n    return {\n      target: convertedTarget,\n      transitionEnd: transitionEnd\n    };\n  } else {\n    return {\n      target: target,\n      transitionEnd: transitionEnd\n    };\n  }\n};\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target: target,\n    transitionEnd: transitionEnd\n  };\n}\nexport { BoundingBoxDimension, positionalValues, unitConversion };","map":{"version":3,"names":["__assign","__read","number","px","isKeyframesTarget","invariant","transformProps","findDimensionValueType","positionalKeys","Set","isPositionalKey","key","has","hasPositionalKey","target","Object","keys","some","setAndResetVelocity","value","to","set","isNumOrPxType","v","BoundingBoxDimension","getPosFromMatrix","matrix","pos","parseFloat","split","getTranslateFromMatrix","pos2","pos3","_bbox","_a","transform","matrix3d","match","transformKeys","nonTranslationalTransformKeys","filter","removeNonTranslationalTransform","visualElement","removedTransforms","forEach","getValue","undefined","push","get","startsWith","length","syncRender","positionalValues","width","_b","x","_c","paddingLeft","_d","paddingRight","max","min","height","y","paddingTop","paddingBottom","top","left","bottom","right","convertChangedValueTypes","changedKeys","originBbox","measureViewportBox","element","getInstance","elementComputedStyle","getComputedStyle","display","origin","setStaticValue","targetBbox","checkAndConvertChangedValueTypes","transitionEnd","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","hasValue","from","fromType","toType","numKeyframes","fromIndex","i","current","Array","isArray","map","scrollY_1","indexOf","window","pageYOffset","convertedTarget","scrollTo","unitConversion"],"sources":["C:/Users/vikas/OneDrive/Desktop/k folder/nk-portfolio/node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs"],"sourcesContent":["import { __assign, __read } from 'tslib';\r\nimport { number, px } from 'style-value-types';\r\nimport { isKeyframesTarget } from '../../../animation/utils/is-keyframes-target.mjs';\r\nimport { invariant } from 'hey-listen';\r\nimport { transformProps } from '../../html/utils/transform.mjs';\r\nimport { findDimensionValueType } from '../value-types/dimensions.mjs';\r\n\r\nvar positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    \"x\",\r\n    \"y\",\r\n]);\r\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\r\nvar hasPositionalKey = function (target) {\r\n    return Object.keys(target).some(isPositionalKey);\r\n};\r\nvar setAndResetVelocity = function (value, to) {\r\n    // Looks odd but setting it twice doesn't render, it'll just\r\n    // set both prev and current to the latest value\r\n    value.set(to, false);\r\n    value.set(to);\r\n};\r\nvar isNumOrPxType = function (v) {\r\n    return v === number || v === px;\r\n};\r\nvar BoundingBoxDimension;\r\n(function (BoundingBoxDimension) {\r\n    BoundingBoxDimension[\"width\"] = \"width\";\r\n    BoundingBoxDimension[\"height\"] = \"height\";\r\n    BoundingBoxDimension[\"left\"] = \"left\";\r\n    BoundingBoxDimension[\"right\"] = \"right\";\r\n    BoundingBoxDimension[\"top\"] = \"top\";\r\n    BoundingBoxDimension[\"bottom\"] = \"bottom\";\r\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\r\nvar getPosFromMatrix = function (matrix, pos) {\r\n    return parseFloat(matrix.split(\", \")[pos]);\r\n};\r\nvar getTranslateFromMatrix = function (pos2, pos3) {\r\n    return function (_bbox, _a) {\r\n        var transform = _a.transform;\r\n        if (transform === \"none\" || !transform)\r\n            return 0;\r\n        var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\r\n        if (matrix3d) {\r\n            return getPosFromMatrix(matrix3d[1], pos3);\r\n        }\r\n        else {\r\n            var matrix = transform.match(/^matrix\\((.+)\\)$/);\r\n            if (matrix) {\r\n                return getPosFromMatrix(matrix[1], pos2);\r\n            }\r\n            else {\r\n                return 0;\r\n            }\r\n        }\r\n    };\r\n};\r\nvar transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    var removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach(function (key) {\r\n        var value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    // Apply changes to element before measurement\r\n    if (removedTransforms.length)\r\n        visualElement.syncRender();\r\n    return removedTransforms;\r\n}\r\nvar positionalValues = {\r\n    // Dimensions\r\n    width: function (_a, _b) {\r\n        var x = _a.x;\r\n        var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? \"0\" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? \"0\" : _d;\r\n        return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\r\n    },\r\n    height: function (_a, _b) {\r\n        var y = _a.y;\r\n        var _c = _b.paddingTop, paddingTop = _c === void 0 ? \"0\" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? \"0\" : _d;\r\n        return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\r\n    },\r\n    top: function (_bbox, _a) {\r\n        var top = _a.top;\r\n        return parseFloat(top);\r\n    },\r\n    left: function (_bbox, _a) {\r\n        var left = _a.left;\r\n        return parseFloat(left);\r\n    },\r\n    bottom: function (_a, _b) {\r\n        var y = _a.y;\r\n        var top = _b.top;\r\n        return parseFloat(top) + (y.max - y.min);\r\n    },\r\n    right: function (_a, _b) {\r\n        var x = _a.x;\r\n        var left = _b.left;\r\n        return parseFloat(left) + (x.max - x.min);\r\n    },\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\r\n    var originBbox = visualElement.measureViewportBox();\r\n    var element = visualElement.getInstance();\r\n    var elementComputedStyle = getComputedStyle(element);\r\n    var display = elementComputedStyle.display;\r\n    var origin = {};\r\n    // If the element is currently set to display: \"none\", make it visible before\r\n    // measuring the target bounding box\r\n    if (display === \"none\") {\r\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\r\n    }\r\n    /**\r\n     * Record origins before we render and update styles\r\n     */\r\n    changedKeys.forEach(function (key) {\r\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\r\n    });\r\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\r\n    visualElement.syncRender();\r\n    var targetBbox = visualElement.measureViewportBox();\r\n    changedKeys.forEach(function (key) {\r\n        // Restore styles to their **calculated computed style**, not their actual\r\n        // originally set style. This allows us to animate between equivalent pixel units.\r\n        var value = visualElement.getValue(key);\r\n        setAndResetVelocity(value, origin[key]);\r\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\r\n    });\r\n    return target;\r\n};\r\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\r\n    if (origin === void 0) { origin = {}; }\r\n    if (transitionEnd === void 0) { transitionEnd = {}; }\r\n    target = __assign({}, target);\r\n    transitionEnd = __assign({}, transitionEnd);\r\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\r\n    // We want to remove any transform values that could affect the element's bounding box before\r\n    // it's measured. We'll reapply these later.\r\n    var removedTransformValues = [];\r\n    var hasAttemptedToRemoveTransformValues = false;\r\n    var changedValueTypeKeys = [];\r\n    targetPositionalKeys.forEach(function (key) {\r\n        var value = visualElement.getValue(key);\r\n        if (!visualElement.hasValue(key))\r\n            return;\r\n        var from = origin[key];\r\n        var fromType = findDimensionValueType(from);\r\n        var to = target[key];\r\n        var toType;\r\n        // TODO: The current implementation of this basically throws an error\r\n        // if you try and do value conversion via keyframes. There's probably\r\n        // a way of doing this but the performance implications would need greater scrutiny,\r\n        // as it'd be doing multiple resize-remeasure operations.\r\n        if (isKeyframesTarget(to)) {\r\n            var numKeyframes = to.length;\r\n            var fromIndex = to[0] === null ? 1 : 0;\r\n            from = to[fromIndex];\r\n            fromType = findDimensionValueType(from);\r\n            for (var i = fromIndex; i < numKeyframes; i++) {\r\n                if (!toType) {\r\n                    toType = findDimensionValueType(to[i]);\r\n                    invariant(toType === fromType ||\r\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\r\n                }\r\n                else {\r\n                    invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            toType = findDimensionValueType(to);\r\n        }\r\n        if (fromType !== toType) {\r\n            // If they're both just number or px, convert them both to numbers rather than\r\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\r\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\r\n                var current = value.get();\r\n                if (typeof current === \"string\") {\r\n                    value.set(parseFloat(current));\r\n                }\r\n                if (typeof to === \"string\") {\r\n                    target[key] = parseFloat(to);\r\n                }\r\n                else if (Array.isArray(to) && toType === px) {\r\n                    target[key] = to.map(parseFloat);\r\n                }\r\n            }\r\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\r\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\r\n                (from === 0 || to === 0)) {\r\n                // If one or the other value is 0, it's safe to coerce it to the\r\n                // type of the other without measurement\r\n                if (from === 0) {\r\n                    value.set(toType.transform(from));\r\n                }\r\n                else {\r\n                    target[key] = fromType.transform(to);\r\n                }\r\n            }\r\n            else {\r\n                // If we're going to do value conversion via DOM measurements, we first\r\n                // need to remove non-positional transform values that could affect the bbox measurements.\r\n                if (!hasAttemptedToRemoveTransformValues) {\r\n                    removedTransformValues =\r\n                        removeNonTranslationalTransform(visualElement);\r\n                    hasAttemptedToRemoveTransformValues = true;\r\n                }\r\n                changedValueTypeKeys.push(key);\r\n                transitionEnd[key] =\r\n                    transitionEnd[key] !== undefined\r\n                        ? transitionEnd[key]\r\n                        : target[key];\r\n                setAndResetVelocity(value, to);\r\n            }\r\n        }\r\n    });\r\n    if (changedValueTypeKeys.length) {\r\n        var scrollY_1 = changedValueTypeKeys.indexOf(\"height\") >= 0\r\n            ? window.pageYOffset\r\n            : null;\r\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\r\n        // If we removed transform values, reapply them before the next render\r\n        if (removedTransformValues.length) {\r\n            removedTransformValues.forEach(function (_a) {\r\n                var _b = __read(_a, 2), key = _b[0], value = _b[1];\r\n                visualElement.getValue(key).set(value);\r\n            });\r\n        }\r\n        // Reapply original values\r\n        visualElement.syncRender();\r\n        // Restore scroll position\r\n        if (scrollY_1 !== null)\r\n            window.scrollTo({ top: scrollY_1 });\r\n        return { target: convertedTarget, transitionEnd: transitionEnd };\r\n    }\r\n    else {\r\n        return { target: target, transitionEnd: transitionEnd };\r\n    }\r\n};\r\n/**\r\n * Convert value types for x/y/width/height/top/left/bottom/right\r\n *\r\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\r\n *\r\n * @internal\r\n */\r\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\r\n    return hasPositionalKey(target)\r\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\r\n        : { target: target, transitionEnd: transitionEnd };\r\n}\r\n\r\nexport { BoundingBoxDimension, positionalValues, unitConversion };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}