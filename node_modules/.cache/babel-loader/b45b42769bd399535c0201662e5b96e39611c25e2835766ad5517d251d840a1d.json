{"ast":null,"code":"import { __read, __spreadArray } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { env } from '../../utils/process.mjs';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nvar getChildKey = function (child) {\n  return child.key || \"\";\n};\nfunction updateChildLookup(children, allChildren) {\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n    allChildren.set(key, child);\n  });\n}\nfunction onlyElements(children) {\n  var filtered = [];\n  // We use forEach here instead of map as map mutates the component key by preprending `.$`\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n    custom = _a.custom,\n    _b = _a.initial,\n    initial = _b === void 0 ? true : _b,\n    onExitComplete = _a.onExitComplete,\n    exitBeforeEnter = _a.exitBeforeEnter,\n    _c = _a.presenceAffectsLayout,\n    presenceAffectsLayout = _c === void 0 ? true : _c;\n  // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n  var _d = __read(useForceUpdate(), 1),\n    forceRender = _d[0];\n  var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n  if (forceRenderLayoutGroup) forceRender = forceRenderLayoutGroup;\n  var isMounted = useIsMounted();\n  // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n  var filteredChildren = onlyElements(children);\n  var childrenToRender = filteredChildren;\n  var exiting = new Set();\n  // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n  var presentChildren = useRef(childrenToRender);\n  // A lookup table to quickly reference components by key\n  var allChildren = useRef(new Map()).current;\n  // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n  var isInitialRender = useRef(true);\n  useIsomorphicLayoutEffect(function () {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  useUnmountEffect(function () {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exiting.clear();\n  });\n  if (isInitialRender.current) {\n    return React.createElement(React.Fragment, null, childrenToRender.map(function (child) {\n      return React.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout\n      }, child);\n    }));\n  }\n  // If this is a subsequent render, deal with entering and exiting children\n  childrenToRender = __spreadArray([], __read(childrenToRender), false);\n  // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey);\n  // Diff the present children with our target children and mark those that are exiting\n  var numPresent = presentKeys.length;\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    }\n  }\n  // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  }\n  // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key);\n      // Remove this child from the present children\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1);\n      // Defer re-rendering until all exiting children have indeed left\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        if (isMounted.current === false) return;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n    childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child));\n  });\n  // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child);\n  });\n  if (env !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n  return React.createElement(React.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\nexport { AnimatePresence };","map":{"version":3,"names":["__read","__spreadArray","React","useContext","useRef","cloneElement","Children","isValidElement","env","useForceUpdate","useIsMounted","PresenceChild","LayoutGroupContext","useIsomorphicLayoutEffect","useUnmountEffect","getChildKey","child","key","updateChildLookup","children","allChildren","forEach","set","onlyElements","filtered","push","AnimatePresence","_a","custom","_b","initial","onExitComplete","exitBeforeEnter","_c","presenceAffectsLayout","_d","forceRender","forceRenderLayoutGroup","isMounted","filteredChildren","childrenToRender","exiting","Set","presentChildren","Map","current","isInitialRender","clear","createElement","Fragment","map","isPresent","undefined","presentKeys","targetKeys","numPresent","length","i","indexOf","add","size","get","insertionIndex","onExit","delete","removeIndex","findIndex","presentChild","splice","has","console","warn"],"sources":["C:/Users/vikas/OneDrive/Desktop/k folder/nk-portfolio/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["import { __read, __spreadArray } from 'tslib';\r\nimport * as React from 'react';\r\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\r\nimport { env } from '../../utils/process.mjs';\r\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\r\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\r\nimport { PresenceChild } from './PresenceChild.mjs';\r\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\r\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\r\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\r\n\r\nvar getChildKey = function (child) { return child.key || \"\"; };\r\nfunction updateChildLookup(children, allChildren) {\r\n    children.forEach(function (child) {\r\n        var key = getChildKey(child);\r\n        allChildren.set(key, child);\r\n    });\r\n}\r\nfunction onlyElements(children) {\r\n    var filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    Children.forEach(children, function (child) {\r\n        if (isValidElement(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nvar AnimatePresence = function (_a) {\r\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\r\n    // We want to force a re-render once all exiting animations have finished. We\r\n    // either use a local forceRender function, or one from a parent context if it exists.\r\n    var _d = __read(useForceUpdate(), 1), forceRender = _d[0];\r\n    var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\r\n    if (forceRenderLayoutGroup)\r\n        forceRender = forceRenderLayoutGroup;\r\n    var isMounted = useIsMounted();\r\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\r\n    var filteredChildren = onlyElements(children);\r\n    var childrenToRender = filteredChildren;\r\n    var exiting = new Set();\r\n    // Keep a living record of the children we're actually rendering so we\r\n    // can diff to figure out which are entering and exiting\r\n    var presentChildren = useRef(childrenToRender);\r\n    // A lookup table to quickly reference components by key\r\n    var allChildren = useRef(new Map()).current;\r\n    // If this is the initial component render, just deal with logic surrounding whether\r\n    // we play onMount animations or not.\r\n    var isInitialRender = useRef(true);\r\n    useIsomorphicLayoutEffect(function () {\r\n        isInitialRender.current = false;\r\n        updateChildLookup(filteredChildren, allChildren);\r\n        presentChildren.current = childrenToRender;\r\n    });\r\n    useUnmountEffect(function () {\r\n        isInitialRender.current = true;\r\n        allChildren.clear();\r\n        exiting.clear();\r\n    });\r\n    if (isInitialRender.current) {\r\n        return (React.createElement(React.Fragment, null, childrenToRender.map(function (child) { return (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\r\n    }\r\n    // If this is a subsequent render, deal with entering and exiting children\r\n    childrenToRender = __spreadArray([], __read(childrenToRender), false);\r\n    // Diff the keys of the currently-present and target children to update our\r\n    // exiting list.\r\n    var presentKeys = presentChildren.current.map(getChildKey);\r\n    var targetKeys = filteredChildren.map(getChildKey);\r\n    // Diff the present children with our target children and mark those that are exiting\r\n    var numPresent = presentKeys.length;\r\n    for (var i = 0; i < numPresent; i++) {\r\n        var key = presentKeys[i];\r\n        if (targetKeys.indexOf(key) === -1) {\r\n            exiting.add(key);\r\n        }\r\n    }\r\n    // If we currently have exiting children, and we're deferring rendering incoming children\r\n    // until after all current children have exiting, empty the childrenToRender array\r\n    if (exitBeforeEnter && exiting.size) {\r\n        childrenToRender = [];\r\n    }\r\n    // Loop through all currently exiting components and clone them to overwrite `animate`\r\n    // with any `exit` prop they might have defined.\r\n    exiting.forEach(function (key) {\r\n        // If this component is actually entering again, early return\r\n        if (targetKeys.indexOf(key) !== -1)\r\n            return;\r\n        var child = allChildren.get(key);\r\n        if (!child)\r\n            return;\r\n        var insertionIndex = presentKeys.indexOf(key);\r\n        var onExit = function () {\r\n            allChildren.delete(key);\r\n            exiting.delete(key);\r\n            // Remove this child from the present children\r\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\r\n            presentChildren.current.splice(removeIndex, 1);\r\n            // Defer re-rendering until all exiting children have indeed left\r\n            if (!exiting.size) {\r\n                presentChildren.current = filteredChildren;\r\n                if (isMounted.current === false)\r\n                    return;\r\n                forceRender();\r\n                onExitComplete && onExitComplete();\r\n            }\r\n        };\r\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\r\n    });\r\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\r\n    // the same tree between renders\r\n    childrenToRender = childrenToRender.map(function (child) {\r\n        var key = child.key;\r\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\r\n    });\r\n    if (env !== \"production\" &&\r\n        exitBeforeEnter &&\r\n        childrenToRender.length > 1) {\r\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\r\n    }\r\n    return (React.createElement(React.Fragment, null, exiting.size\r\n        ? childrenToRender\r\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\r\n};\r\n\r\nexport { AnimatePresence };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}